#?-------------------------------------------------------------------------------------------------------------------------------------------------------------
#?                                                                ____            ____  _       _
#?                                                               |  _ \ _   _    |  _ \| | ___ | |_
#?                                                               | |_) | | | |   | |_) | |/ _ \| __|
#?                                                               |  __/| |_| |   |  __/| | (_) | |_
#?                                                               |_|    \__, |___|_|   |_|\___/ \__|
#?                                                                      |___/_____|
#?-------------------------------------------------------------------------------------------------------------------------------------------------------------

import os
import sys
import json
import copy
import socket
import datetime
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import natsort
from pathlib import Path

#?-------------------------------------------------------------------------------------------------------------------------------------------------------------
# Dependencies that were previously imported from other files
#?-------------------------------------------------------------------------------------------------------------------------------------------------------------

# Base64 encoded BMW logo (you'll need to provide this or remove it)
BMW_Base64_Logo = "bmw_logo_base64.txt"  # Update this path

# Configuration dictionaries (you'll need to populate these with your actual data)
JSON = {
    "iterSplit": False,
    "FFT": True,
    "TF_Config": "DCDC_S",
    "figureName": [],
    "figureComment": []
}

# Mapping dictionaries (populate with your actual mappings)
pmap_multi = {
    'Peak_Voltages': {},
    'Peak_Currents': {}
}

pmap_plt = {}
pmap_plt_ctrl = {}
pwm_dict = {}

# Constant dictionaries (populate with your actual constants)
constant_dict = {}

# Plot title list (populate with your actual plot titles)
plt_title_list = []

# Harmonic orders for FFT (populate with your actual harmonics)
harmonics = []

# Index ranges (populate with your actual values)
idx_start = 0
idx_end = 0
Y_list = [0, 0, 0, 0]

# Get current script name
scriptname = os.path.splitext(os.path.basename(__file__))[0]

#?-------------------------------------------------------------------------------------------------------------------------------------------------------------

class HTML_REPORT:
    """
    This Class is used for creating a full html report using tables , plots ...
    Functions / methods included in this calss :
    """
    def __init__(self, ResultsPath='', utc='', standalone=True):
        """
        Initialize the HTML_REPORT class with various attributes and load configuration data.
        """
        self.ResultsPath = ResultsPath
        self.utc = utc
        self.hostname = str(socket.gethostname())
        self.script_name = scriptname
        self.values_dict = dict()
        self.config_dicts = dict()
        self.configkey_list = []
        self.configval_list = []
        self.valkey_list = []
        self.values_list = []
        self.headerColor = '#009ADA'
        self.even_rc = '#E0E0E0'
        self.odd_rc = 'white'
        self.title = f"<html><head><title>{self.script_name}_Report_{self.utc}_{self.hostname}</title></head><body></body></html>"
        self.separator = "<html><body><hr style='height:1px;border:none;color:#333;background-color:#333;'></body></html>"
        self.image = ''
        self.tab_val_list = []
        self.tab_conf_list = []
        self.iter_param_key = []
        self.iter_param_val = []
        self.iter_param_unt = []
        self.note = "N/A"
        self.constants_list = []
        self.constants_vals = []
        self.constants_units = []
        self.json_file = "Standalone_variables.json" if standalone else "Input_vars.json"
        self.json_path = os.path.join(os.getcwd(), "Script", "assets", self.json_file).replace("\\", "/")
        
        # Try to load JSON data if file exists
        try:
            with open(self.json_path) as f:
                self.data = json.load(f)
            for i in range(1, 11):
                setattr(self, f"X{i}", eval(self.data[f"X{i}"]))
        except FileNotFoundError:
            print(f"Warning: JSON file {self.json_path} not found. Using default values.")
            self.data = {}
        
        self.base64_img()

    def base64_img(self):
        """
        Read a text file containing a base64 encoded image and store it as a string.
        """
        try:
            with open(BMW_Base64_Logo, 'r') as fin:
                lines = fin.readlines()
            for line in lines:
                self.image += line
            fin.close()
        except FileNotFoundError:
            print(f"Warning: Base64 image file {BMW_Base64_Logo} not found.")
            self.image = ""

    def set_tab_dict(self, misc, input_dict):
        """
        Extract relevant configuration information from a dictionary of nested dictionaries.
        """
        source_mdlvar = copy.deepcopy(input_dict)
        self.config_dicts = {'ToFile': source_mdlvar['Common']['ToFile']}
        self.values_dict = self.keys_exists(self.config_dicts, source_mdlvar)
        self.tab_val_list.append(self.values_dict)
        self.tab_conf_list.append(self.config_dicts)

    def keys_exists(self, element, *keys):
        """
        Check if *keys (nested) exists in `element` (dict).
        """
        if not isinstance(element, dict):
            raise AttributeError('keys_exists() expects dict as first argument.')
        if len(keys) == 0:
            raise AttributeError('keys_exists() expects at least two arguments, one given.')
        
        _element = element
        for key in keys:
            try:
                _element = _element[key]
            except KeyError:
                return False
        return _element

    def table_data(self, dictt, key_list, val_list, prefix=''):
        """
        Extract data from a nested dictionary and store in two separate lists.
        """
        if isinstance(dictt, dict):
            for k, v2 in dictt.items():
                p2 = "{}['{}']".format(prefix, k)
                self.table_data(v2, key_list, val_list, p2)
        else:
            key_list.append(prefix)
            val_list.append(str(dictt))

    def add_constant_table(self, csv_file):
        """
        Creates a table of constants by taking the mean values of certain columns from a CSV file.
        """
        df = pd.read_csv(csv_file)
        
        for _, val in constant_dict.items():
            column_values = df.iloc[:, val[1]]
            column_values = column_values.to_numpy()
            column_values = column_values[-50:]
            self.constants_list.append(val[0])
            self.constants_vals.append(np.mean(column_values).round(2))
            self.constants_units.append(val[2])
        
        const_Nrow = len(self.constants_vals)
        
        constants_tab = go.Table(
            header=dict(
                values=['PARAMETER', 'VALUE', 'UNIT'],
                fill_color=self.headerColor,
                font_size=12,
                line_color='darkslategray',
                align='center'
            ),
            cells=dict(
                values=[self.constants_list, self.constants_vals, self.constants_units],
                fill_color=[[self.odd_rc, self.even_rc] * const_Nrow],
                align=['left', 'center'],
                font_size=10,
                line_color='darkslategray'
            )
        )
        
        table_figure = make_subplots(
            rows=1,
            cols=1,
            shared_xaxes=True,
            horizontal_spacing=0.03,
            specs=[[{"type": "table"}]]
        )
        
        table_figure.update_layout(title_text="Operational Steady-State Parameters:", font_size=16)
        table_figure.add_trace(constants_tab, row=1, col=1)
        
        return table_figure

    def add_table(self, i=0):
        """
        Constructs two tables from given data from two dictionaries - one for configurations, the other for values.
        """
        self.configkey_list.clear()
        self.configval_list.clear()
        self.valkey_list.clear()
        self.values_list.clear()
        
        self.table_data(self.tab_conf_list[i], self.configkey_list, self.configval_list)
        self.table_data(self.tab_val_list[i], self.valkey_list, self.values_list)
        
        table_height = 600
        config_Nrow = len(self.configval_list)
        val_Nrow = len(self.values_list)
        param_Nrow = len(self.iter_param_val[i])
        
        config_table = go.Table(
            header=dict(
                values=['SUBSYSTEM', 'CONFIGURATION'],
                fill_color=self.headerColor,
                font_size=12,
                line_color='darkslategray',
                align='center'
            ),
            cells=dict(
                values=[self.configkey_list, self.configval_list],
                fill_color=[[self.odd_rc, self.even_rc] * config_Nrow],
                align=['left', 'center'],
                font_size=10,
                line_color='darkslategray'
            )
        )
        
        val_table = go.Table(
            header=dict(
                values=['ALL PARAMETERS', 'VALUE'],
                fill_color=self.headerColor,
                font_size=12,
                line_color='darkslategray',
                align='center'
            ),
            cells=dict(
                values=[self.valkey_list, self.values_list],
                fill_color=[[self.odd_rc, self.even_rc] * val_Nrow],
                align=['left', 'center'],
                font_size=10,
                line_color='darkslategray'
            )
        )
        
        updated_vals_table = go.Table(
            header=dict(
                values=['FOCUSED PARAMETERS', 'VALUE', 'UNIT'],
                fill_color=self.headerColor,
                font_size=12,
                line_color='darkslategray',
                align='center'
            ),
            cells=dict(
                values=[self.iter_param_key[i], self.iter_param_val[i], self.iter_param_unt[i]],
                fill_color=[[self.odd_rc, self.even_rc] * param_Nrow],
                align=['left', 'center'],
                font_size=10,
                line_color='darkslategray'
            )
        )
        
        readme_message = go.Table(
            header=dict(
                values=['SIMULATION NOTES'],
                fill_color=self.headerColor,
                font_size=12,
                line_color='darkslategray',
                align='center'
            ),
            cells=dict(
                values=[self.note],
                align=['left'],
                font_size=12,
                line_color='darkslategray',
            )
        )
        
        table_figure = make_subplots(
            rows=2,
            cols=2,
            shared_xaxes=True,
            horizontal_spacing=0.03,
            specs=[[{"type": "table"}, {"type": "table"}], [{"type": "table"}, {"type": "table"}]]
        )
        
        table_figure.update_layout(height=table_height, title_text="Simulation Model Configurations & Parameters:", font_size=16)
        table_figure.add_trace(config_table, row=1, col=1)
        table_figure.add_trace(val_table, row=1, col=2)
        table_figure.add_trace(readme_message, row=2, col=1)
        table_figure.add_trace(updated_vals_table, row=2, col=2)
        
        return table_figure

    def plot_scopes(self, fName, odict, xticks=None, yticks=None, xaxis_range=None, yaxis_range=None, Legend=True):
        """
        Generates a list of subplots for the data in a CSV file.
        """
        figure_list = []
        df = pd.read_csv(fName)
        
        for key, _ in odict.items():
            titles = [odict[key][x][1][0] for x in range(len(odict[key]))]
            fig = make_subplots(rows=len(odict[key]), cols=1, subplot_titles=titles, shared_xaxes=True, vertical_spacing=0.08)
            
            for j in range(len(odict[key])):
                for i in range(len(odict[key][j][0])):
                    X, Y = df.iloc[:, 0], df.iloc[:, odict[key][j][2][i]]
                    
                    if len(set(Y)) == 1:
                        new_df = pd.DataFrame({'X': [X.iloc[0], X.iloc[-1]], 'Y': [Y.iloc[0], Y.iloc[-1]]})
                        fig.add_trace(go.Scatter(x=new_df['X'], y=new_df['Y'], name=odict[key][j][0][i]), row=j+1, col=1)
                    else:
                        fig.add_trace(go.Scatter(x=X, y=Y, name=odict[key][j][0][i]), row=j+1, col=1)
                
                fig['layout'][f'yaxis{j+1}']['title'] = odict[key][j][3][i]
            
            fig['layout'][f'xaxis{j+1}']['title'] = 'Time [s]'
            fig.update_xaxes(range=xaxis_range, dtick=xticks)
            fig.update_yaxes(range=yaxis_range, dtick=yticks)
            
            if Legend == True:
                if JSON['TF_Config'] == 'DCDC_D':
                    fig.update_layout(title={'text': str(key)}, showlegend=True)
                else:
                    if len(odict[key]) > 1:
                        fig.update_layout(title={'text': str(key)}, showlegend=True)
                    else:
                        fig.update_layout(
                            showlegend=False,
                            plot_bgcolor='#f8fafd',
                            yaxis2=dict(anchor='free', position=0, side='left')
                        )
            else:
                fig.update_layout(showlegend=False)
            
            fig.update_traces(hovertemplate=None)
            fig.update_layout(hovermode="x unified")
            figure_list.append(fig)
        
        return figure_list

    def multiplot(self, csv_file):
        """
        Generate a plot of voltage and current data from a simulation output file.
        """
        dff = pd.read_csv(csv_file)
        Voltages_labels_dict = pmap_multi['Peak_Voltages']
        Currents_labels_dict = pmap_multi['Peak_Currents']
        PWM_labels_dict = pwm_dict
        voltage_keys = list(Voltages_labels_dict.keys())
        Current_keys = list(Currents_labels_dict.keys())
        PWM_keys = list(PWM_labels_dict.keys())
        
        fig = make_subplots(specs=[[{"secondary_y": True}]])
        
        for each in Current_keys:
            fig.add_trace(
                go.Scatter(
                    x=dff.iloc[:, 0],
                    y=dff.iloc[:, Currents_labels_dict.get(each)],
                    name=each,
                    mode="lines",
                    line=dict(shape='linear', dash='dot')
                ), secondary_y=False
            )
        
        for each in voltage_keys:
            fig.add_trace(
                go.Scatter(
                    x=dff.iloc[:, 0],
                    y=dff.iloc[:, Voltages_labels_dict.get(each)],
                    name=each,
                    mode="lines",
                    line=dict(shape='linear')
                ), secondary_y=True
            )
        
        for each in PWM_keys:
            fig.add_trace(
                go.Scatter(
                    x=dff.iloc[:, 0],
                    y=dff.iloc[:, PWM_labels_dict.get(each)],
                    name=each,
                    mode="lines+markers",
                    line=dict(shape='linear', dash='dashdot')
                ), secondary_y=True
            )
        
        button_all = dict(
            label='CURRENTS & VOLTAGES & PWM',
            method='update',
            args=[{'visible': [True for i in range(len(list(Currents_labels_dict.values())))] +
                             [True for j in range(len(list(Voltages_labels_dict.values())))] +
                             [True for j in range(len(list(Voltages_labels_dict.values())))],
                  'title': 'CURRENTS & VOLTAGES & PWM',
                  'showlegend': True}]
        )
        
        button_curr = dict(
            label='CURRENTS',
            method='update',
            args=[{'visible': [True for i in range(len(list(Currents_labels_dict.values())))] +
                             [False for j in range(len(list(Voltages_labels_dict.values())))] +
                             [False for j in range(len(list(Voltages_labels_dict.values())))],
                  'title': 'CURRENTS',
                  'showlegend': True}]
        )
        
        button_volt = dict(
            label='VOLTAGES',
            method='update',
            args=[{'visible': [False for i in range(len(list(Currents_labels_dict.values())))] +
                             [True for j in range(len(list(Voltages_labels_dict.values())))] +
                             [False for j in range(len(list(Voltages_labels_dict.values())))],
                  'title': 'VOLTAGES',
                  'showlegend': True}]
        )
        
        button_pwm = dict(
            label='PWM SIGNALS',
            method='update',
            args=[{'visible': [False for i in range(len(list(Currents_labels_dict.values())))] +
                             [False for j in range(len(list(Voltages_labels_dict.values())))] +
                             [True for j in range(len(list(Voltages_labels_dict.values())))],
                  'title': 'PWM SIGNALS',
                  'showlegend': True}]
        )
        
        button_pwm_volt = dict(
            label='PWM & VOLTAGES',
            method='update',
            args=[{'visible': [False for i in range(len(list(Currents_labels_dict.values())))] +
                             [True for j in range(len(list(Voltages_labels_dict.values())))] +
                             [True for j in range(len(list(Voltages_labels_dict.values())))],
                  'title': 'PWM SIGNALS & VOLTAGES',
                  'showlegend': True}]
        )
        
        button_pwm_curr = dict(
            label='PWM & CURRENTS',
            method='update',
            args=[{'visible': [True for i in range(len(list(Currents_labels_dict.values())))] +
                             [False for j in range(len(list(Voltages_labels_dict.values())))] +
                             [True for j in range(len(list(Voltages_labels_dict.values())))],
                  'title': 'PWM SIGNALS & CURRENTS',
                  'showlegend': True}]
        )
        
        fig.update_layout(
            updatemenus=[go.layout.Updatemenu(
                active=0,
                buttons=[button_all, button_curr, button_volt, button_pwm, button_pwm_volt, button_pwm_curr],
                direction='up',
                x=0,
                xanchor='left',
                y=-0.1,
                yanchor='top')
            ],
            title="VOLTAGES VS CURRENTS VS PWM",
            xaxis=dict(title='Time [ s ]'),
            yaxis=dict(
                side="left",
                title="Current [ A ]",
                titlefont=dict(color="#1f77b4"),
                tickfont=dict(color="#1f77b4")
            ),
            yaxis2=dict(
                side="right",
                title="Voltage [ V ]",
                titlefont=dict(color="#1f77b4"),
                tickfont=dict(color="#1f77b4"),
            ),
            plot_bgcolor='#f8fafd'
        )
        
        return fig

    def gen_iter_report(self, path, label_dict, html_path, Y_axis_label, type, auto_open):
        """
        Generates an iteration report in HTML format for a set of CSV files.
        """
        fig_list = []
        include_plotlyjs = 'cdn'
        labels_dict = dict(label_dict)
        dict_keys = list(labels_dict.keys())
        csv_files = [f for f in os.listdir(path) if f.endswith('.csv') and not f.endswith('_MAP.csv') and not f.endswith('_Standalone.csv')]
        
        if len(csv_files) >= 1:
            csv_files = natsort.natsorted(csv_files)
            dfs = [pd.read_csv(os.path.join(path, f)) for f in csv_files]
            
            for each in dict_keys:
                fig = make_subplots()
                C = 1
                for df in dfs:
                    fig.add_trace(
                        go.Scatter(
                            x=df.iloc[:, 0],
                            y=df.iloc[:, labels_dict.get(each)],
                            name=str("Iter :" + str(C) + " | ") + each,
                            mode="lines",
                            line=dict(shape='linear')
                        )
                    )
                    
                    fig.update_layout(
                        showlegend=True,
                        title=each,
                        xaxis=dict(title='Time [ S ]'),
                        yaxis=dict(
                            side="left",
                            title=Y_axis_label,
                            titlefont=dict(color="#1f77b4"),
                            tickfont=dict(color="#1f77b4")
                        ),
                        plot_bgcolor='#f8fafd'
                    )
                    C += 1
                fig_list.append(fig)
                
                if JSON['iterSplit']:
                    date = str(datetime.datetime.now().replace(microsecond=0))
                    with open(html_path + "_" + each + ".html", 'w') as f:
                        f.write(self.title)
                        f.write('<style>    .container  {position: relative;text-align: right;color: black;}    \
                                                .Simulation {position: absolute;top: 10px;left: 16px;}              \
                                                .DateTime   {position: absolute;top: 50px;left: 16px;}              \
                                                .Sim_ID     {position: absolute;top: 90px;left: 16px;}              \
                                    </style>'\
                                    f'<div class="container">  \
                                                <img src="data:image/png;base64,{self.image}"/> \
                                                <div class  =   "Simulation"><b> Simulation     :</b> {" ".rjust(60, " ")} {self.script_name}</div>\
                                                <div class  =   "DateTime"> <b> Date & Time     :</b> {" ".rjust(60, " ")} {date} </div> \
                                                <div class  =   "Sim_ID"> <b> Simulation ID     :</b> {" ".ljust(60, " ")} {self.utc}</div> \
                                    </div>')
                        
                        f.write(self.separator)
                        f.write(fig.to_html(full_html=False, include_plotlyjs=include_plotlyjs))
                        f.write(self.separator)
                    f.close()
            
            if not JSON['iterSplit']:
                date = str(datetime.datetime.now().replace(microsecond=0))
                with open(html_path + "_" + type + ".html", 'w') as f:
                    f.write(self.title)
                    f.write('<style>    .container  {position: relative;text-align: right;color: black;}    \
                                            .Simulation {position: absolute;top: 10px;left: 16px;}              \
                                            .DateTime   {position: absolute;top: 50px;left: 16px;}              \
                                            .Sim_ID     {position: absolute;top: 90px;left: 16px;}              \
                                </style>'\
                                f'<div class="container">  \
                                            <img src="data:image/png;base64,{self.image}"/> \
                                            <div class  =   "Simulation"><b> Simulation     :</b> {" ".rjust(60, " ")} {self.script_name}</div>\
                                            <div class  =   "DateTime"> <b> Date & Time     :</b> {" ".rjust(60, " ")} {date} </div> \
                                            <div class  =   "Sim_ID"> <b> Simulation ID     :</b> {" ".ljust(60, " ")} {self.utc}</div> \
                                </div>')
                    
                    f.write(self.separator)
                    for fig_i in fig_list:
                        f.write(fig_i.to_html(full_html=False, include_plotlyjs=include_plotlyjs))
                        f.write(self.separator)
                f.close()
            
            if auto_open:
                import webbrowser
                uri = Path(html_path).absolute().as_uri()
                webbrowser.open(uri)

    def return_headers(self, header_file):
        """
        Returns list of headers from json header file.
        """
        with open(header_file, 'r') as f:
            header = json.load(f)
        f.close()
        return header

    def fft_bar_plot(self, current_fft_csv, voltage_fft_csv, iteration):
        """
        Generate a bar plot of FFT magnitudes for current and voltage signals.
        """
        Current_headers = self.return_headers((os.getcwd()).replace("\\", "/") + "/Script/assets/HEADER_FILES/FFT_Current.json")
        Voltage_headers = self.return_headers((os.getcwd()).replace("\\", "/") + "/Script/assets/HEADER_FILES/FFT_Voltage.json")
        dfcurr = pd.read_csv(current_fft_csv, header=None, index_col=None)
        dfvolt = pd.read_csv(voltage_fft_csv, header=None, index_col=None)
        figure_list = []
        
        for i in range(len(plt_title_list)):
            fig = make_subplots(rows=1, cols=1, specs=[[{"secondary_y": True}]])
            
            current_idx_list = [Current_headers.index(plt_title_list[i][1])] if len(plt_title_list[i]) < 5 else [Current_headers.index(plt_title_list[i][1]), Current_headers.index(plt_title_list[i][2])]
            voltage_idx_list = [Voltage_headers.index(plt_title_list[i][2])] if len(plt_title_list[i]) < 5 else [Voltage_headers.index(plt_title_list[i][3]), Voltage_headers.index(plt_title_list[i][4])]
            
            current_titles = [plt_title_list[i][1]] if len(plt_title_list[i]) < 5 else [plt_title_list[i][1], plt_title_list[i][2]]
            voltage_titles = [plt_title_list[i][2]] if len(plt_title_list[i]) < 5 else [plt_title_list[i][3], plt_title_list[i][4]]
            
            if JSON['FFT']:
                for c, name in enumerate(current_titles):
                    fig.add_trace(go.Bar(x=harmonics, y=dfcurr.iloc[iteration * len(harmonics): (iteration + 1) * len(harmonics), current_idx_list[c]], name=name), row=1, col=1, secondary_y=False)
                for j, name in enumerate(voltage_titles):
                    fig.add_trace(go.Bar(x=harmonics, y=dfvolt.iloc[iteration * len(harmonics): (iteration + 1) * len(harmonics), voltage_idx_list[j]], name=name), row=1, col=1, secondary_y=True)
            else:
                return []
            
            fig.update_layout(
                title=f'FFT Magnitudes - {plt_title_list[i][0]}',
                xaxis_title='Harmonic Orders',
                xaxis=dict(tickvals=harmonics, ticktext=harmonics),
                yaxis=dict(
                    side="left",
                    title="Current Magnitude",
                    titlefont=dict(color="#1f77b4"),
                    tickfont=dict(color="#1f77b4")),
                yaxis2=dict(
                    side="right",
                    title="Voltage Magnitude",
                    titlefont=dict(color="#1f77b4"),
                    tickfont=dict(color="#1f77b4")),
                plot_bgcolor='#f8fafd',
                barmode='overlay'
            )
            figure_list.append(fig)
        
        return figure_list

    def shuffle_lists(self, list1, list2):
        """
        Shuffle two lists by interleaving their elements.
        """
        list3 = []
        for i in range(len(list1)):
            list3.append(list1[i])
            if list2:
                list3.append(list2[i])
        return list3

    def fft_gen_iter_report(self, FFT_file, title, csv_path, html_path, type, auto_open):
        """
        Generate an HTML report with FFT magnitudes for multiple iterations.
        """
        include_plotlyjs = 'cdn'
        headers = self.return_headers((os.getcwd()).replace("\\", "/") + f"/Script/assets/HEADER_FILES/{FFT_file}")
        df = pd.read_csv(csv_path, header=None, index_col=None)
        figure_list = []
        num_iterations = df.shape[0] // len(harmonics)
        
        for column in range(df.shape[1]):
            fig = go.Figure()
            
            for iteration in range(num_iterations):
                iteration_data = df.iloc[iteration * len(harmonics): (iteration + 1) * len(harmonics), column]
                fig.add_trace(
                    go.Bar(
                        x=harmonics,
                        y=iteration_data,
                        name=f'{headers[column]} {title} : Iteration {iteration + 1}'
                    ))
            
            fig.update_layout(
                title=f'FFT Magnitudes - {headers[column]}',
                showlegend=True,
                xaxis_title='Harmonic Orders',
                yaxis_title='Magnitude',
                xaxis=dict(tickvals=harmonics, ticktext=harmonics),
                barmode='stack'
            )
            figure_list.append(fig)
            
            if JSON['iterSplit']:
                date = str(datetime.datetime.now().replace(microsecond=0))
                with open(html_path + "_" + str(headers[column]) + "_FFT.html", 'w') as f:
                    f.write(self.title)
                    f.write('<style>    .container  {position: relative;text-align: right;color: black;}    \
                                        .Simulation {position: absolute;top: 10px;left: 16px;}              \
                                        .DateTime   {position: absolute;top: 50px;left: 16px;}              \
                                        .Sim_ID     {position: absolute;top: 90px;left: 16px;}              \
                            </style>'\
                            f'<div class="container">  \
                                        <img src="data:image/png;base64,{self.image}"/> \
                                        <div class  =   "Simulation"><b> Simulation     :</b> {" ".rjust(60, " ")} {self.script_name}</div>\
                                        <div class  =   "DateTime"> <b> Date & Time     :</b> {" ".rjust(60, " ")} {date} </div> \
                                        <div class  =   "Sim_ID"> <b> Simulation ID     :</b> {" ".ljust(60, " ")} {self.utc}</div> \
                            </div>')
                    f.write(self.separator)
                    f.write(fig.to_html(full_html=False, include_plotlyjs=include_plotlyjs))
                    f.write(self.separator)
                f.close()
        
        if not JSON['iterSplit']:
            date = str(datetime.datetime.now().replace(microsecond=0))
            with open(html_path + "_" + type + "_FFT.html", 'w') as f:
                f.write(self.title)
                f.write('<style>    .container  {position: relative;text-align: right;color: black;}    \
                                    .Simulation {position: absolute;top: 10px;left: 16px;}              \
                                    .DateTime   {position: absolute;top: 50px;left: 16px;}              \
                                    .Sim_ID     {position: absolute;top: 90px;left: 16px;}              \
                        </style>'\
                        f'<div class="container">  \
                                    <img src="data:image/png;base64,{self.image}"/> \
                                    <div class  =   "Simulation"><b> Simulation     :</b> {" ".rjust(60, " ")} {self.script_name}</div>\
                                    <div class  =   "DateTime"> <b> Date & Time     :</b> {" ".rjust(60, " ")} {date} </div> \
                                    <div class  =   "Sim_ID"> <b> Simulation ID     :</b> {" ".ljust(60, " ")} {self.utc}</div> \
                        </div>')
                f.write(self.separator)
                for fig_i in figure_list:
                    f.write(fig_i.to_html(full_html=False, include_plotlyjs=include_plotlyjs))
                    f.write(self.separator)
            f.close()
        
        if auto_open:
            import webbrowser
            uri = Path(html_path).absolute().as_uri()
            webbrowser.open(uri)

    def append_to_html(self, csv_filename, figure, filename, auto_open, i=1, include_plotlyjs='cdn'):
        """
        Appends figures to an existing html file.
        """
        multiplot = self.multiplot(csv_filename)
        tables = self.add_table(i)
        date = str(datetime.datetime.now().replace(microsecond=0))
        
        if JSON["figureName"] and JSON["figureComment"]:
            self.FigureNames = [plt_title_list[i][0] for i in range(len(plt_title_list))]
            self.fftFigureNames = [f'FFT {plt_title_list[i][0]}' for i in range(len(plt_title_list))]
            self.CtrlFigureNames = list(pmap_plt_ctrl.keys())
            self.FigTitles = (self.shuffle_lists(self.FigureNames, self.fftFigureNames)) + self.CtrlFigureNames
            self.Comments = [" " for _ in range((2 * len(plt_title_list)) + len(self.CtrlFigureNames))]
        
        with open(filename, 'w') as f:
            f.write(self.title)
            f.write('<style>    .container  {position: relative;text-align: right;color: black;}                                        \
                                .Simulation {position: absolute;top: 10px;left: 16px;}                                                  \
                                .DateTime   {position: absolute;top: 50px;left: 16px;}                                                  \
                                .Sim_ID     {position: absolute;top: 90px;left: 16px;}                                                  \
                    </style>'                                                                                                           \
                    f'<div class="container">                                                                                           \
                                <img src="data:image/png;base64,{self.image}"/>                                                         \
                                <div class  =   "Simulation"><b> Simulation     :</b> {" ".rjust(60, " ")} {self.script_name}</div>     \
                                <div class  =   "DateTime"> <b> Date & Time     :</b> {" ".rjust(60, " ")} {date} </div>                \
                                <div class  =   "Sim_ID"> <b> Simulation ID     :</b> {" ".ljust(60, " ")} {self.utc}</div>             \
                    </div>')
            
            f.write(self.separator)
            f.write(tables.to_html(include_plotlyjs=include_plotlyjs))
            f.write(self.separator)
            f.write(multiplot.to_html(include_plotlyjs=include_plotlyjs))
            f.write(self.separator)
            
            if JSON["figureName"] and JSON["figureComment"]:
                for b in range(len(JSON["figureName"])):
                    self.Comments[self.FigTitles.index(JSON["figureName"][b])] = JSON["figureComment"][b]
            
            for i in range(len(figure)):
                f.write(figure[i].to_html(full_html=False, include_plotlyjs=include_plotlyjs))
                if JSON["figureName"] and JSON["figureComment"]:
                    if not self.Comments[i] == " ":
                        f.write(f'<input type="text" style="font-size:9pt;height:50px;width:1500px;" value="{self.Comments[i]}" readonly="readonly">')
                f.write(self.separator)
            
            constant_tables = self.add_constant_table(csv_filename)
            f.write(constant_tables.to_html(include_plotlyjs=include_plotlyjs))
            self.constants_list.clear()
            self.constants_vals.clear()
            self.constants_units.clear()
            
            if JSON["figureName"] and JSON["figureComment"]:
                self.FigTitles.clear()
                self.FigureNames.clear()
                self.fftFigureNames.clear()
                self.Comments.clear()
            
            f.write('<html>                                                                     \
                        <body>                                                                  \
                            <div>                                                               \
                                <br />                                                          \
                                <label for="files" class="btn">SELECT HEADER FILE</label>       \
                                <br />                                                          \
                                <br />                                                          \
                                <input type="file" id="LoadJasonFile" onchange="uploadJson()"/> \
                                <br />                                                          \
                                <br />                                                          \
                                <label for="files" class="btn">SELECT RAW DATA</label>          \
                                <br />                                                          \
                                <br />                                                          \
                                <input type="file" id="fileInput" onchange="uploadFile()" />    \
                                <br />                                                          \
                            <div>                                                               \
                            <br />                                                              \
                            <div id="checkboxContainer"></div>                                  \
                                <br />                                                          \
                                <button id="downloadButton" disabled>Download</button>          \
                                <br />                                                          \
                        </body>                                                                 \
                        <script src="app.js"></script>                                          \
                    </html>')
        f.close()
        
        if auto_open:
            import webbrowser
            uri = Path(filename).absolute().as_uri()
            webbrowser.open(uri)

    def auto_plot(self, simutil, fileLog, misc, open=False, iterReport=False):
        """
        Generates an HTML report containing multiple plots.
        """
        misc.tic()
        ResDir = (os.getcwd()).replace("\\", "/") + "/Script/" + "D".upper() + "ata/Res/" + self.script_name + "_" + self.utc + "_suffix" + "/CSV_TIME_SERIES"
        MAPS_dir = (os.getcwd()).replace("\\", "/") + "/Script/" + "D".upper() + "ata/Res/" + self.script_name + "_" + self.utc + "_suffix" + "/CSV_MAPS"
        FFT_curr_path = MAPS_dir + "/FFT_Current_Map.csv"
        FFT_volt_path = MAPS_dir + "/FFT_Voltage_Map.csv"
        file_list = natsort.natsorted([os.path.join(ResDir, f) for f in os.listdir(ResDir) if f.endswith('.csv')])
        legend = True if JSON['TF_Config'] == 'DCDC_D' else False
        c = 0
        
        if JSON['TF_Config'] == 'DCDC_S' or 'DCDC_D':
            # simutil.postProcessing.drop_Extra_Cols(FFT_curr_path, idx_start, idx_end)
            pass
        
        if iterReport:
            self.gen_iter_report(ResDir, pmap_multi['Peak_Currents'], fileLog.resultfolder + "/HTML_REPORTS/" + "HTML_Report_" + self.utc, "[ A ]", "Currents", open)
            self.gen_iter_report(ResDir, pmap_multi['Peak_Voltages'], fileLog.resultfolder + "/HTML_REPORTS/" + "HTML_Report_" + self.utc, "[ V ]", "Voltages", open)
        
        if iterReport and JSON['FFT']:
            self.fft_gen_iter_report("FFT_Current.json", " Currents_FFT", FFT_curr_path, fileLog.resultfolder + "/HTML_REPORTS/" + "HTML_Report_" + self.utc, "Currents_FFT", open)
            self.fft_gen_iter_report("FFT_Voltage.json", "Voltages_FFT", FFT_volt_path, fileLog.resultfolder + "/HTML_REPORTS/" + "HTML_Report_" + self.utc, "Voltages_FFT", open)
        
        for x in range(len(file_list)):
            FFT_figs = self.fft_bar_plot(FFT_curr_path, FFT_volt_path, x)
            figures_list = self.plot_scopes(file_list[x], pmap_plt, Legend=legend)
            figures_list_ = self.shuffle_lists(figures_list, FFT_figs)
            
            if JSON['TF_Config'] == 'DCDC_S' or 'DCDC_D':
                # simutil.postProcessing.drop_Extra_Cols(file_list[x], sum(Y_list[0:3]), sum(Y_list[0:4]))
                figures_list_ctrl = self.plot_scopes(file_list[x], pmap_plt_ctrl, Legend=True)
                figures_list_.extend(figures_list_ctrl)
            
            c += 1
            self.append_to_html(file_list[x], figures_list_, fileLog.resultfolder + "/HTML_REPORTS" + "/HTML_REPORT_" + self.utc + "_" + str(c) + ".html", auto_open=open, i=c-1)
            self.constants_list, self.constants_vals, self.constants_units, figures_list_ = [], [], [], []
        
        fileLog.Separator()
        fileLog.log(f"Generating HTML Report    {'= '.rjust(49+17, ' ')}{str(misc.toc())} seconds.\n")
        file_list.clear()


#?-------------------------------------------------------------------------------------------------------------------------------------------------------------
# Example usage and test
#?-------------------------------------------------------------------------------------------------------------------------------------------------------------

if __name__ == "__main__":
    # Create a simple test instance
    report = HTML_REPORT(utc=datetime.datetime.now().strftime("%Y%m%d_%H%M%S"))
    
    print("HTML_REPORT class initialized successfully!")
    print(f"Script name: {report.script_name}")
    print(f"UTC: {report.utc}")
    print(f"Hostname: {report.hostname}")